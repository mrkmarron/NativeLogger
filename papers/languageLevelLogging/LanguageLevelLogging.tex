\documentclass[twocolumn,10pt]{article}

\begin{document}

\title{Language Level Logging} \author{Mark Marron}
\maketitle

\begin{abstract} 
Logging is a fundamental part of the software development, deployment, and
monitoring lifecycle but logging support is often provided as an afterthought or
via a library API in a languages core runtime. We argue that given the critical
nature of logging in modern development, the unique needs of the APIs involved,
and the opportunities for optimizing it using semantic knowledge, logging should
be included as a central part of the language and runtime designs. This paper
presents a \emph{language level logging} design which includes support for
logging functionality at all levels of a programming language including, syntax,
runtime support, and hooks for DevOps integration.

Using this integrated approach we build a logging system that supports near
zero-costs for disabled log statements, low cost lazy-copying for enabled log
statements, selective persitance of logging output, unified control of logging
output accross different libraries, and DevOps integration for use with modern
cloud-based deployments. To evaluate these concepts we provide two
implementations -- one fully integrated into the design of the \emph{fluent}
programming language and a second, which has slightly reduced features and
performance, but is available as a library for Node.js hosted JavaScript
applictions.
\end{abstract}

\section{Introduction} 
Logging has always been a important tool for software developers in
understanding their applications. However, as DevOps oriented workflows have
become more prevelent, logging is becoming an even larger consideration when
building applications. A key area driving this shift is the use of cloud-based
applications and the integration of application monitoring dashboards, such as
Stack Driver~\cite{StackDriver}, NSolid~\cite{NSolid}, or
AppInsights~\cite{AppInsights}, which ingest logs from an application, correlate
this information with other aspects of the system, and provide this in a useful
dashboard format for developers. The additional value provided by these
dashboards and the ability to quickly act on this data makes the inclusion of
rich logging data an integral part of an applications development.

%Existing logging library implementations, as provided in core or third-party libraries, are unable 
%to satifactorially meet the demands of logging in moden applications including:
%\begin{enumerate}
%\item Parasitic costs of logging statements in the code but disabled at runtime including tatements 
%needed for generating debug logs.
%\item Costs of writing data to the log in general and in particular data, such as dates or JSON objects, 
%which require non-trival formatting to emit.
%\item Tension between the desire to generate detailed logs when an error occours vs. the desire 
%to avoid logging large amounts of uninteresting data.
%\item Difficult mergeing data logged from multiple modules in an application in a 
%way that is automatically parsable to use in a monitoring dashboard.
%\end{enumerate}
%As a result developers must use existing libraries with care to limit undersireable perfomance impacts, 
%direct logging output to the appropriate channels, and figure out how to effectively parse the data 
%that is written from various sources. Consider the following sample JavaScript code:

Existing logging library implementations, as provided via core or third party
libraries, are unable to satifactorially meet the demands of logging in moden
applications. As a result developers must use existing libraries with care to
limit undersireable logging related perfomance impacts, work to direct logging
output from core or third-party modules to the appropriate channels, and figure
out how to effectively parse the data that is written from various sources.
Consider the following sample JavaScript code which illustrates a number of
concrete issues encountered by Node.js~\cite{Node} developers today.

%%TODO add nice code environment here
\noindent
{\texttt
const logger = require('winston'); \\
logger.setTransport("/tmp/logs/log.txt"); \\
function foo(name, flag) \{ \\
    console.log("Hello"); \\
    logger.info("World"); \\
    for(var i = 0; i < 1000; ++i) \{ \\
        logger.debug(`Data = \$\{  \{ nval: name, cval: i \}  \}`); \\
        ...\\
    \} \\
    \\
    const ok = check(name, flag);\\
    \\
    logger.info(`check(\$\{name\}, \$\{flag\}) is \$\{ok\}`);\\
    if(!ok) \{\\
        logger.warn("Something went wrong...");\\
    \}\\
\}
}

The first is the challenge of different loggers being used in various parts of
the code in this case \texttt{console.log} writing to the \texttt{stdout} and a
popular framework called \texttt{Winston} which has been configured to write to
a file. As a result some log output will appear on the console while other
output will end up in a file. Further, if a developer changes the logging output
level for \texttt{Winston}, from say \texttt{info} to \texttt{warn}, this will
not change the output level of the \texttt{console} output. Developers can work
around this to some degree by enforcing the use of a single logging framework
for their code but they will not always be able to control the frameworks used
by external libraries.

The next challenge comes from the ad-hoc nature of log message formatting. In
most cases the logging API's provided for developers are setup to take a format
string and some formattable arguments. This is great for quick and easy outputs
but quickly leads to a plethora of ad-hoc formats that cannot be easily parsed
and loaded into dashboard or analytics tooling. Modern logging frameworks,
log4j~\cite{log4j}, Winston~\cite{Winston}, Bunyan~\cite{Bunyan}, etc. provide
some support for consistently formatting ans structuring output but
fundamentally this problem is left as a problem development teams need to solve
via coding conventions and reviews.

In addition to these functionality issues there are also performance problems
that plague existing logging solutions. One concern is that even if a given
logging level is disabled, as \texttt{debug} and \texttt{trace} levels usually
are, the code to generate and format the log message is still executed. This can
lead to code that looks like it will not be executed but that in reality incurrs
large parasitic costs. This can be seen in the \texttt{logger.debug} statement
in the example, which at the default level does not print to the log, but will
still result in the creation of the literal object and generation of a format
string on every execution of the loop. This cost leads developers to defensively
remove these statements from code instead of depending on the runtime to
eliminate their costs when deploying the application.

Finally, there is the odd issue that, in many cases a developer only cares about
much of the data in the log if/when there is actually an issue that needs to be
investigated. In other cases this information represents pure execution overhead
for the application. An example of this is the \texttt{logger.info} message
about the args and result of the \texttt{check} call. In the case of a
successful execution the content of this log statement is not useful and the
cost of producing this plus the increased log footprint is pure overhead.
However, if the \texttt{check} statement fails then having this information
about what events led up to the failure may be cirtical in diagnosing/fixing the
issue. In current logging frameworks this is an unavoidable conundrum and, in
any case where the trace history is needed, the logging statements must be
added.

To address these issues we propose a new apporach, \emph{language level
logging}, in which logging is viewed as a first class feature in the
design/implementation of a programming language and runtime instead of simply
another library to be included. Taking this view enables us to leverage language
semantics, focused compiler optimisations, and semantic knowledge in the runtime
to provide a uniform and high performance logging API.

\noindent
The contributions of this paper include:
\begin{itemize}
\item The view that logging is a fundamental aspect of programming and should be
included as a first class part of language, compiler, and runtime design.

\item A novel logging technique that uses immutatility semantics in the
programming language to enable ultra-low cost logging which is
5$\times$-100$\times$ faster than existing approaches.

\item A novel dual-level approach to log generation and writing that allows a
programmer to log execution data eagerly but only pay the cost of writting it to
the log if it turns out to be interesting/relevant.

\item Implementation of this technique in a new programming language,
\emph{fluentpl}, which fully realizes the logging ideas in this paper. 

\item An implementation in Node.js using the ChakraCore~\cite{NodeChakraCore}
JavaScript engine to demonstrate that key ideas can be applied to existing
languages/runtimes and provide an production implementation for use in
performance evaluations.
\end{itemize}

\section{Design Goals}

The major issues this proposal is intended to address are:

\noindent
Lack of high performance logging primitives and fundamental logging challenges.
\begin{enumerate}
 \item Cost of writing data to the log -- particularly with data formatted via 
    `util.inspect` and info such as timestamps.
 \item Ongoing tension between log detail when triaging issues and cost of logging 
    large amounts of 'uninteresting' data.
\item Parasitic costs of disabled logging statements which still execute code to 
    generate dead logging data (e.g., constructing unused strings).
\item Compiler optimizations of both enabled and disabled logging statements.
\end{enumerate}

\noindent
Challenges integrating log data from different sources and difficulty in post processing.
\begin{enumerate}
\item Difficulty in specifying uniform and appropriate logging levels across 
    multiple packages -- and quite possibly multiple logging frameworks.
\item Difficulty in ensuring all logging data is written to a consistent location 
    across multiple packages -- and quite possibly multiple logging frameworks.
\item Correlating fundamental information such as  
    transaction ids, such as async context and HTTP requests, and to log relevant 
    events in the core libraries with user logging data -- same for performance info.
\end{enumerate}

\section{Language Level Logging}

\section{Implementation}

\section{Evaluation}

\section{Conclusion}

\section{Notes} log output scheduling -- critical for devops/cloud integration
-- should be background task

\end{document}
